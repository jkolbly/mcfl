use std::collections::HashMap;

use crate::{
    ast::{ASTNode, ASTNodeType},
    error::CompileError,
    ir::IR,
    tree::{NodeId, Tree},
};

/// Generate an IR (intermediate representation) from an AST (abstract syntax tree)
pub fn compile(ast: &Tree<ASTNode>) -> Result<IR, CompileError> {
    let mut ir = IR::new();

    let funcs = get_mcfuncs(ast)?;

    for id in funcs.values() {
        compile_mcfunc(&mut ir, ast, *id)?;
    }

    Ok(ir)
}

/// Compile a single mcfunction and add it to the IR.
fn compile_mcfunc(ir: &mut IR, ast: &Tree<ASTNode>, mcfunc: NodeId) -> Result<(), CompileError> {
    todo!()
}

/// Find all the mcfunctions that must be compiled in an AST. Resulting HashMap maps mfunction names (as they appear in MCFL source) to node ID's.
///
/// Note that other mcfunction files will also be generated by the compilation process, but each of these is guaranteed its own file.
fn get_mcfuncs(ast: &Tree<ASTNode>) -> Result<HashMap<String, NodeId>, CompileError> {
    let mut map = HashMap::new();

    for child in ast.get_children(ast.get_root()?)? {
        if let ASTNodeType::MCFunction { name } = &ast.get_node(*child)?.node_type {
            map.insert(name.to_string(), *child);
        }
    }

    Ok(map)
}
