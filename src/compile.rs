use std::collections::HashMap;

use crate::{
    ast::{ASTNode, ASTNodeType},
    error::CompileError,
    ir::IR,
    tree::{NodeId, Tree},
};

/// Generate an IR (intermediate representation) from an AST (abstract syntax tree)
pub fn compile(ast: &Tree<ASTNode>) -> Result<IR, CompileError> {
    let mut ir = IR::new();

    Ok(ir)
}

/// Find all the mcfunctions that must be compiled in an AST. Resulting HashMap maps mfunction names (as they appear in MCFL source) to node ID's.
///
/// Note that other mcfunction files will also be generated by the compilation process, but each of these is guaranteed its own file.
fn get_mcfuncs(ast: &Tree<ASTNode>) -> Result<HashMap<String, NodeId>, CompileError> {
    let mut map = HashMap::new();

    for child in ast.get_children(ast.get_root()?)? {
        if let ASTNodeType::MCFunction { name } = &ast.get_node(*child)?.node_type {
            map.insert(name.to_string(), *child);
        }
    }

    Ok(map)
}
